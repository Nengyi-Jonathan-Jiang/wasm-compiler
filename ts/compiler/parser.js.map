{"version":3,"file":"parser.js","sourceRoot":"","sources":["parser.ts"],"names":[],"mappings":"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","sourcesContent":["class ParseRule {\r\n    public readonly lhs: TokenType;\r\n    public readonly rhs: SymbolString;\r\n    private readonly str: string;\r\n\r\n    constructor(lhs: TokenType, rhs: SymbolString) {\r\n        this.lhs = lhs;\r\n        this.rhs = rhs;\r\n        this.str = `${this.lhs} := ${this.rhs}`;\r\n    }\r\n\r\n    public get length() {\r\n        return this.rhs.length\r\n    }\r\n\r\n    public toString() {\r\n        return this.str;\r\n    }\r\n}\r\n\r\nclass Grammar {\r\n    public readonly rules: ParseRule[];\r\n    public readonly startRule: ParseRule;\r\n    readonly allSymbols: SSet<TokenType>;\r\n    readonly nonTerminals: SSet<TokenType>;\r\n    private readonly terminals: SSet<TokenType>;\r\n    private readonly nullableSymbols: SSet<TokenType>;\r\n\r\n    private readonly firstSets: SMap<TokenType, SSet<TokenType>>;\r\n    private readonly followSets: SMap<TokenType, SSet<TokenType>>;\r\n\r\n    readonly startsWith: SMap<TokenType, ParseRule[]>;\r\n\r\n    constructor(startSymbol: TokenType, ...rules: ParseRule[]) {\r\n        this.rules = rules;\r\n\r\n        this.startRule = new ParseRule(TokenType.START, new SymbolString(startSymbol));\r\n        this.rules.push(this.startRule);\r\n\r\n        this.allSymbols = new SSet<TokenType>();\r\n        this.nonTerminals = new SSet<TokenType>();\r\n        this.terminals = new SSet<TokenType>();\r\n        this.nullableSymbols = new SSet();\r\n\r\n        this.firstSets = new SMap<TokenType, SSet<TokenType>>();\r\n        this.followSets = new SMap<TokenType, SSet<TokenType>>();\r\n        this.startsWith = new SMap<TokenType, ParseRule[]>();\r\n\r\n        this.nonTerminals.add(TokenType.START);\r\n        this.allSymbols.add(TokenType.START);\r\n        this.allSymbols.add(TokenType.END);\r\n\r\n        for (const rule of rules) {\r\n            this.nonTerminals.add(rule.lhs);\r\n            for (const symbol of rule.rhs) {\r\n                this.allSymbols.add(symbol);\r\n            }\r\n        }\r\n\r\n        this.terminals.addAll(...[...this.allSymbols].filter(i => !this.nonTerminals.has(i)));\r\n\r\n        for (const symbol of this.allSymbols) {\r\n            this.startsWith.add(symbol, []);\r\n        }\r\n        for (const rule of rules) {\r\n            this.startsWith.get(rule.lhs).push(rule);\r\n        }\r\n\r\n        for (const symbol of this.allSymbols) {\r\n            this.firstSets.add(symbol, new SSet<TokenType>());\r\n            this.followSets.add(symbol, new SSet<TokenType>());\r\n            if (this.isTerminal(symbol)) {\r\n                this.firstSets.get(symbol).add(symbol);\r\n            }\r\n        }\r\n\r\n        this.followSets.get(TokenType.START).add(TokenType.END);\r\n\r\n        // set calculations\r\n        let updated = true;\r\n        while (updated) {\r\n            updated = false;\r\n            for (const rule of this.rules) {\r\n                const {lhs, rhs} = rule;\r\n\r\n                // Update FIRST sets\r\n                const firstSet = this.firstSets.get(lhs);\r\n                let brk = false;\r\n                for (const symbol of rhs) {\r\n                    updated ||= firstSet.addAll(...this.firstSets.get(symbol));\r\n                    if (!this.nullableSymbols.has(symbol)) {\r\n                        brk = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!brk) {\r\n                    updated ||= this.nullableSymbols.add(lhs);\r\n                }\r\n\r\n                // Update FOLLOW sets\r\n                let aux = this.followSets.get(lhs);\r\n                for (let symbol of rhs.symbols.slice().reverse()) {\r\n                    if (this.isNonTerminal(symbol)) {\r\n                        updated ||= this.followSets.get(symbol).addAll(...aux);\r\n                    }\r\n                    if (this.nullableSymbols.has(symbol)) {\r\n                        aux = new SSet<TokenType>(...aux);\r\n                        aux.addAll(...this.firstSets.get(symbol));\r\n                    } else aux = this.firstSets.get(symbol);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    public isNonTerminal(symbol: TokenType) {\r\n        return this.nonTerminals.has(symbol);\r\n    }\r\n\r\n    public isTerminal(symbol: TokenType) {\r\n        return this.terminals.has(symbol);\r\n    }\r\n\r\n    private readonly memoization: SMap<SymbolString, SSet<TokenType>> = new SMap<SymbolString, SSet<TokenType>>();\r\n\r\n    public getFirstSet(string: SymbolString): SSet<TokenType> {\r\n        if (string.length === 0)\r\n            return new SSet(TokenType.EPSILON);\r\n        if (this.memoization.has(string))\r\n            return this.memoization.get(string);\r\n        const res = this.nullableSymbols.has(string.get(0))\r\n            ? new SSet(...this.firstSets.get(string.get(0)), ...this.getFirstSet(string.substr(1)))\r\n            : new SSet(...this.firstSets.get(string.get(0)))\r\n        this.memoization.add(string, res);\r\n        return res;\r\n    }\r\n\r\n    public toString() {\r\n        return this.rules.join(\"\\n\");\r\n    }\r\n}\r\n\r\nclass TableEntry {\r\n    public static Shift = class Shift extends TableEntry {\r\n        public readonly nextState: number;\r\n\r\n        constructor(nextState: number) {\r\n            super();\r\n            this.nextState = nextState;\r\n        }\r\n    }\r\n\r\n    public static Reduce = class Reduce extends TableEntry {\r\n        public readonly rule: ParseRule;\r\n\r\n        constructor(reduceRule: ParseRule) {\r\n            super();\r\n            this.rule = reduceRule;\r\n        }\r\n    }\r\n\r\n    public static Accept = class Accept extends TableEntry {\r\n    }\r\n}\r\n\r\nclass ParsingTable {\r\n    public readonly numStates: number;\r\n    private readonly actionTable: SMap<TokenType, TableEntry>[];\r\n    private readonly gotoTable: SMap<TokenType, number>[];\r\n\r\n    constructor(numStates: number) {\r\n        this.numStates = numStates;\r\n\r\n        this.actionTable = new Array(numStates).fill(null).map(_ => new SMap<TokenType, TableEntry>());\r\n        this.gotoTable = new Array(numStates).fill(null).map(_ => new SMap<TokenType, number>());\r\n    }\r\n\r\n    public getAction(state: number, symbol: TokenType) {\r\n        return this.actionTable[state].get(symbol);\r\n    }\r\n\r\n    public getGoto(state: number, symbol: TokenType) {\r\n        return this.gotoTable[state].get(symbol);\r\n    }\r\n\r\n    public setActionReduce(state: number, symbol: TokenType, rule: ParseRule) {\r\n        this.actionTable[state].add(symbol, new TableEntry.Reduce(rule));\r\n    }\r\n\r\n    public setActionShift(state: number, symbol: TokenType, nextState: number) {\r\n        this.actionTable[state].add(symbol, new TableEntry.Shift(nextState));\r\n    }\r\n\r\n    public setActionAccept(state: number, symbol: TokenType) {\r\n        this.actionTable[state].add(symbol, new TableEntry.Accept());\r\n    }\r\n\r\n    public setGoto(state: number, symbol: TokenType, n: number) {\r\n        this.gotoTable[state].add(symbol, n);\r\n    }\r\n}\r\n\r\nclass Item {\r\n    public readonly rule: ParseRule;\r\n    public readonly pos: number;\r\n    public readonly lookahead: SSet<TokenType>;\r\n    private str: string;\r\n\r\n    constructor(rule: ParseRule, pos: number, lookahead: SSet<TokenType>) {\r\n        this.rule = rule;\r\n        this.pos = pos;\r\n        this.lookahead = lookahead;\r\n    }\r\n\r\n    public get isFinished() {\r\n        return this.pos >= this.rule.length;\r\n    }\r\n\r\n    toString() {\r\n        if (this.str === undefined) this.str = `${this.rule.lhs} := ${this.rule.rhs} pos=${this.pos} ?= ${this.lookahead}`;\r\n        return this.str\r\n    }\r\n\r\n    public get next() {\r\n        return this.isFinished ? null : this.rule.rhs.get(this.pos);\r\n    }\r\n\r\n    public shift() {\r\n        return new Item(this.rule, this.pos + 1, this.lookahead);\r\n    }\r\n\r\n    public static merge(s1: Item, s2: Item) {\r\n        const lookahead = this.mergeLookahead(s1.lookahead, s2.lookahead);\r\n        return new Item(s1.rule, s1.pos, lookahead);\r\n    }\r\n\r\n    public static mergeLookahead(a: SSet<TokenType>, b: SSet<TokenType>){\r\n        //return new SSet<TokenType>(...a, ...b);\r\n        return SSet.from<TokenType>(a, b);\r\n    }\r\n}\r\n\r\n\r\nclass ItemSet {\r\n    private map: Map<string, Item> = new Map<string, Item>();\r\n    private str: string;\r\n    private dirty: boolean = false;\r\n\r\n    constructor(...items: Item[]) {\r\n        this.addAll(...items);\r\n    }\r\n\r\n    private updateRepr() {\r\n        this.str = `{\\n\\t${[...this].join(\"\\n\\t\")}\\n}`;\r\n    }\r\n\r\n    public toString() {\r\n        if (this.dirty) this.updateRepr();\r\n        return this.str;\r\n    }\r\n\r\n    private stringify(item: Item) {\r\n        return item.rule + \"@\" + item.pos;\r\n    }\r\n\r\n    public add(value: Item) {\r\n        if (this.has(value)) {\r\n            const prev = this.get(value);\r\n            const merged = Item.merge(prev, value)\r\n            if (prev.lookahead.size == merged.lookahead.size) return false;\r\n\r\n            this._add(merged);\r\n\r\n            return this.dirty = true;\r\n        }\r\n        this._add(value);\r\n        return this.dirty = true;\r\n    }\r\n\r\n    private _add(value: Item) {\r\n        this.map.set(this.stringify(value), value);\r\n    }\r\n\r\n    public addAll(...values: Item[]) {\r\n        return values.map(value => this.add(value)).some(i => i);\r\n    }\r\n\r\n\r\n    public del(key: Item) {\r\n        let res = this.get(key);\r\n        this.map.delete(this.stringify(key));\r\n        if (res !== undefined) this.dirty = true;\r\n        return res;\r\n    }\r\n\r\n    public has(key: Item) {\r\n        return this.map.has(this.stringify(key));\r\n    }\r\n\r\n    public get(key: Item): Item {\r\n        return this.map.get(this.stringify(key));\r\n    }\r\n\r\n    public get size() {\r\n        return this.map.size;\r\n    }\r\n\r\n    public [Symbol.iterator] = (): Iterator<Item> => this.map.values()\r\n}\r\n\r\nclass ParseTableBuilder {\r\n    private readonly grammar: Grammar;\r\n    public readonly table: ParsingTable;\r\n    private readonly configuratingSets: SMap<ItemSet, number>;\r\n    private readonly successors: SMap<number, SMap<TokenType, number>>;\r\n    private readonly startItem: Item;\r\n\r\n    constructor(grammar: Grammar) {\r\n        this.grammar = grammar;\r\n\r\n        this.startItem = new Item(grammar.startRule, 0, new SSet(TokenType.END));\r\n\r\n        this.configuratingSets = new SMap<ItemSet, number>();\r\n        this.successors = new SMap<number, SMap<TokenType, number>>();\r\n        this.generateConfiguratingSets();\r\n\r\n        this.table = new ParsingTable(this.configuratingSets.size);\r\n        this.generateParsingTable();\r\n    }\r\n\r\n    private generateConfiguratingSets() {\r\n        console.log(\"Generating configurating sets...\");\r\n\r\n        const initialState: ItemSet = this.itemClosure(this.startItem);\r\n        this.configuratingSets.add(initialState, 0);\r\n        this.successors.add(0, new SMap<TokenType, number>());\r\n\r\n        let edge: SSet<ItemSet> = new SSet(initialState);\r\n\r\n        let updated = true;\r\n        while (updated) {\r\n            updated = false;\r\n\r\n            const newEdge: SSet<ItemSet> = new SSet<ItemSet>();\r\n            for (const configuratingSet of edge) {\r\n                const state = this.configuratingSets.get(configuratingSet);\r\n                for (const symbol of this.grammar.allSymbols) {\r\n                    const successor = this.successor(configuratingSet, symbol);\r\n                    if (successor.size == 0) continue;\r\n\r\n                    if (this.addConfiguratingState(state, symbol, successor)) {\r\n                        updated = true;\r\n                        newEdge.add(successor);\r\n                    }\r\n                }\r\n            }\r\n\r\n            edge = newEdge;\r\n        }\r\n    }\r\n\r\n    private addConfiguratingState(state: number, symbol: TokenType, successor: ItemSet): boolean {\r\n        if (!this.configuratingSets.has(successor)) {\r\n            const newState = this.configuratingSets.size;\r\n            this.successors.add(newState, new SMap<TokenType, number>());\r\n            this.configuratingSets.add(successor, newState);\r\n            this.successors.get(state).add(symbol, newState);\r\n            console.log(`Found ${this.configuratingSets.size}th configurating set (${successor.size} items)`);\r\n            return true;\r\n        }\r\n        this.successors.get(state).add(symbol, this.configuratingSets.get(successor));\r\n        return false;\r\n    }\r\n\r\n\r\n    private memoization: SMap<Item, ItemSet> = new SMap<Item, ItemSet>();\r\n\r\n    private itemClosure(item: Item): ItemSet {\r\n        if (this.memoization.has(item)) return this.memoization.get(item);\r\n\r\n        const res = new ItemSet(item);\r\n\r\n        if (item.isFinished) return res;\r\n\r\n        let edge = new ItemSet(...res);\r\n\r\n        let updated = true;\r\n        while (updated) {\r\n            updated = false;\r\n\r\n            let newEdge = new ItemSet();\r\n\r\n            for (const itm of edge) {\r\n\r\n                if (itm.isFinished || !this.grammar.isNonTerminal(itm.next)) continue;\r\n\r\n                const rest = itm.rule.rhs.substr(itm.pos + 1);\r\n\r\n                for (const r of this.grammar.startsWith.get(itm.next)) {\r\n\r\n                    for (const lookahead of itm.lookahead) {\r\n                        const newItem = new Item(r, 0, new SSet<TokenType>(...this.grammar.getFirstSet(rest.concatSymbol(lookahead))));\r\n\r\n                        const isNew = res.add(newItem);\r\n                        if (isNew) {\r\n                            updated = true;\r\n                            newEdge.add(newItem);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            edge = newEdge;\r\n        }\r\n\r\n        this.memoization.add(item, res);\r\n\r\n        return res;\r\n    }\r\n\r\n    private itemSetClosure(itemSet: ItemSet): ItemSet {\r\n        const res: ItemSet = new ItemSet(...itemSet);\r\n        [...itemSet].forEach(item => res.addAll(...this.itemClosure(item)));\r\n        return res;\r\n    }\r\n\r\n    private successor(itemSet: ItemSet, symbol: TokenType): ItemSet {\r\n        const res: ItemSet = new ItemSet();\r\n\r\n        for (const item of itemSet) {\r\n            if (!item.isFinished && item.next == symbol) {\r\n                res.add(item.shift());\r\n            }\r\n        }\r\n        return this.itemSetClosure(res);\r\n    }\r\n\r\n    private generateParsingTable() {\r\n        console.log(\"Generating parsing table entries...\");\r\n\r\n        let i = 0;\r\n        for (const [itemSet, state] of this.configuratingSets) {\r\n            this.generateActionSetEntries(state, itemSet);\r\n            this.generateGotoSetEntries(state);\r\n        }\r\n    }\r\n\r\n    private generateActionSetEntries(state: number, itemSet: ItemSet) {\r\n        for (const item of itemSet) {\r\n            if (item.isFinished && item.rule == this.grammar.startRule) {\r\n                this.table.setActionAccept(state, TokenType.END);\r\n            } else if (item.isFinished) {\r\n                this.generateReductions(state, item);\r\n            } else {\r\n                this.generateShifts(state, item);\r\n            }\r\n        }\r\n    }\r\n\r\n    private generateReductions(state: number, item: Item) {\r\n        for (const symbol of item.lookahead) {\r\n            this.table.setActionReduce(state, symbol, item.rule);\r\n        }\r\n    }\r\n\r\n    private generateShifts(state: number, item: Item) {\r\n        const nextState = this.successors.get(state).get(item.next);\r\n        if (nextState === undefined) return;\r\n        this.table.setActionShift(state, item.next, nextState);\r\n    }\r\n\r\n    private generateGotoSetEntries(state: number) {\r\n        for (const symbol of this.grammar.nonTerminals) {\r\n            const nextState = this.successors.get(state).get(symbol);\r\n            if (nextState === undefined) continue;\r\n            this.table.setGoto(state, symbol, nextState);\r\n        }\r\n    }\r\n}\r\n\r\nclass Parser {\r\n    private readonly table: ParsingTable;\r\n    public readonly Parse: { new(): { accept(token: Token, log?: boolean): void; readonly result: AST; readonly isFinished: boolean } };\r\n\r\n    constructor(table: ParsingTable) {\r\n        this.table = table;\r\n        const _this = this;\r\n        this.Parse = class {\r\n            private readonly stateStack = [0];\r\n            private readonly nodeStack: AST[] = [];\r\n            private readonly parsingTable: ParsingTable;\r\n            private finished = false;\r\n\r\n            public accept(token: Token, log: boolean = false) {\r\n                const state = this.stateStack[this.stateStack.length - 1];\r\n                const entry = _this.table.getAction(state, token.symbol);\r\n\r\n                if (entry === undefined) throw new Error(\"Could not find entry for state \" + state + \" on symbol \" + token);\r\n\r\n                if (entry instanceof TableEntry.Shift) {\r\n                    this.stateStack.push(entry.nextState);\r\n                    this.nodeStack.push(new AST.Leaf(token.symbol, token));\r\n                    if (log) console.log(`Shift on ${token}`);\r\n                } else if (entry instanceof TableEntry.Accept) {\r\n                    this.finished = true;\r\n                    if (log) console.log(`Accept on ${token}`);\r\n                } else if (entry instanceof TableEntry.Reduce) {\r\n                    const {rule: {lhs, length}} = entry;\r\n\r\n                    for (let j = 0; j < length; j++) this.stateStack.pop();\r\n                    this.stateStack.push(table.getGoto(this.stateStack[this.stateStack.length - 1], lhs));\r\n\r\n                    if (length != 1) {\r\n                        const children: AST[] = new Array(length);\r\n                        for (let j = length; j-- > 0;) children[j] = this.nodeStack.pop();\r\n                        this.nodeStack.push(new AST.Node(lhs, ...children));\r\n\r\n                        if (log) console.log(`Reduce ${lhs} := ${children.map(i => i.description).join(\" \")} on ${token}`);\r\n                    }\r\n\r\n                    this.accept(token, log);\r\n                }\r\n            }\r\n\r\n            public get isFinished() {\r\n                return this.finished;\r\n            }\r\n\r\n            public get result() {\r\n                if (!this.isFinished) throw new Error(\"Cannot access result before finished parsing\");\r\n                return this.nodeStack[0];\r\n            }\r\n        }\r\n    }\r\n\r\n    public parse(tokens: Token[], log: boolean = false) {\r\n        const parse = new this.Parse();\r\n        tokens.forEach(token => parse.accept(token, log));\r\n        return parse.result;\r\n    }\r\n\r\n    public static new([str]: [string]) {\r\n        const rules: ParseRule[] = [];\r\n        let startSymbol: TokenType;\r\n\r\n        str.split(/\\s*\\n\\s*/g).filter(i => i !== \"\" && !i.startsWith(\"//\")).map(i => {\r\n            const regex1 = /^(\\S+) := (\\S+( \\S+)*)/;\r\n            const regex2 = /^start (\\S+)$/;\r\n            const regex3 = /^nullable (\\S+)$/;\r\n            if (i.match(regex1) !== null) {\r\n                const [, _lhs, _rhs] = i.match(regex1);\r\n                const lhs = TokenType.create(_lhs), rhs = _rhs.split(\" \").map(j => TokenType.create(j));\r\n                rules.push(new ParseRule(lhs, new SymbolString(...rhs)))\r\n            } else if (i.match(regex2) !== null) {\r\n                const [, lhs] = i.match(regex2);\r\n                startSymbol = TokenType.create(lhs);\r\n            } else if (i.match(regex3) !== null) {\r\n                const [, _lhs] = i.match(regex3);\r\n                const lhs = TokenType.create(_lhs);\r\n                rules.push(new ParseRule(lhs, new SymbolString()));\r\n            } else throw new Error(\"Error in Parser specification\");\r\n        })\r\n\r\n        const grammar = new Grammar(startSymbol, ...rules);\r\n        const table = new ParseTableBuilder(grammar).table;\r\n        return new Parser(table);\r\n    }\r\n}"]}