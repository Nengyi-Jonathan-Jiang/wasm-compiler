{"version":3,"file":"lexer.js","sourceRoot":"","sources":["lexer.ts"],"names":[],"mappings":"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","sourcesContent":["class Lexer {\r\n    static new([str]:[string]){\r\n        const symbols: TokenType[] = [], ignoredSymbols: string[] = [];\r\n\r\n        function sanitize(s:string){\r\n            return s.replace(/[\\\\.,?{}[\\]()^$+*|\\/]/g, \"\\\\$&\");\r\n        }\r\n\r\n        str.split(/\\s*\\n\\s*/g).filter(i => i !== \"\" && !i.startsWith(\"//\")).map(i => {\r\n            const regex1 = /^([0-9A-Za-z\\-]+) := \\/(([^\\\\\\/]|\\\\.)*)\\/$/;\r\n            const regex2 = /^ignore (\\S+)$/;\r\n            const regex3 = /^basic (\\S+)$/;\r\n            if(i.match(regex1) !== null){\r\n                const [, name, pattern] = i.match(regex1);\r\n                symbols.push(TokenType.create(name, new RegExp(`^(${pattern})`, \"gs\")));\r\n            }\r\n            else if(i.match(regex2) !== null){\r\n                const [, name] = i.match(regex2);\r\n                ignoredSymbols.push(name);\r\n            }\r\n            else if(i.match(regex3) !== null){\r\n                const [, name] = i.match(regex3);\r\n                symbols.push(TokenType.create(name, new RegExp(`^(${sanitize(name)})`, \"gs\")));\r\n            }\r\n            else throw new Error(\"Error in Lexer specification\");\r\n        })\r\n\r\n        return new Lexer(symbols, ignoredSymbols);\r\n    }\r\n\r\n    private readonly symbols : TokenType[];\r\n    private readonly ignoredSymbols : Set<string>;\r\n\r\n    constructor(symbols: TokenType[], ignoredSymbols: string[]=[]){\r\n        this.symbols = symbols;\r\n        this.ignoredSymbols = new Set(ignoredSymbols);\r\n    }\r\n\r\n    lex(input:string) {\r\n        const tokens:Token[] = [];\r\n        for (let i = 0; i < input.length;) {\r\n            // If the character is a space, skip it\r\n            if(input.charAt(i).match(/\\s/)){\r\n                i++;\r\n                continue;\r\n            }\r\n\r\n            let token:Token = null;\r\n\r\n            let rest = input.slice(i);\r\n            // Find the next token that corresponds to the input\r\n            for (const symbol of this.symbols) {\r\n                const {pattern} = symbol;\r\n                const [text] = rest.match(pattern) || [null];\r\n                if (text !== null) {\r\n                    token = new Token(symbol, text, i, i += text.length);\r\n                    break;\r\n                }\r\n            }\r\n            if(token === null){\r\n                token = new Token(TokenType.UNKNOWN, input.charAt(i), i, ++i);\r\n            }\r\n\r\n            // Add the token to the list\r\n            if(!this.ignoredSymbols.has(token.symbol.name)) tokens.push(token);\r\n        }\r\n\r\n        tokens.push(new Token(TokenType.END, \"\", -1, -1));\r\n\r\n        return tokens;\r\n    }\r\n}\r\n"]}